import {
  Component,
  OnInit,
  OnDestroy,
  ViewChild,
  ViewChildren,
  QueryList,
  ChangeDetectorRef,
  ChangeDetectionStrategy
} from '@angular/core';
import { DataService } from 'services/data.service';
import { ToolService } from 'services/tool.service';
import { NgForm } from '@angular/forms';
import { v4 as UUIDv4 } from 'uuid';
import { defaultNwQueries } from '../default-nw-queries';
import { ContentTypes } from 'types/contenttypes';
import { ClientUseCases, UseCase } from 'types/use-case';
import { SelectItem } from 'primeng/api/selectitem';
import { Subscription } from 'rxjs';
import { NwServer, NwServers } from 'types/nwserver';
import { Feed, Feeds } from 'types/feed';
import {
  CollectionMeta,
  Collections,
  CollectionType
} from 'types/collection';
import { Collection } from 'types/collection';
import { Preferences } from 'types/preferences';
import * as utils from '../utils';
import { COLLECTION_MODES, HASHING_MODES } from 'types/add-collection-modes';
import dayjs from 'dayjs';
import * as log from 'loglevel';
import { Query } from 'types/query';
import { Params } from '@angular/router';
import { SaServer } from 'types/saserver';
import { ConfirmationService } from 'primeng/api';


@Component({
  selector: 'app-nw-collection-modal',
  changeDetection: ChangeDetectionStrategy.OnPush,
  templateUrl: './nw-collection-modal.component.html',
  styleUrls: [
    './nw-collection-modal.component.scss'
  ]
})

export class NwCollectionModalComponent implements OnInit, OnDestroy {

  constructor(
    private dataService: DataService,
    private toolService: ToolService,
    private changeDetectionRef: ChangeDetectorRef,
    private confirmationService: ConfirmationService
  ) {}

  @ViewChild('addCollectionForm', { static: true }) addCollectionForm: NgForm;
  @ViewChildren('nwNameBox') nameBoxRef: QueryList<any>;

  displayServiceModal = false;

  hashTooltip = 'This is used to find suspicious executables that match a certain hash pattern.  It presently works with Windows and Mac executables.  It also supports executables contained within ZIP or RAR archives.  This will not limit the display of other types of content pulled in from the query.  If found, a tile will be displayed with the hash value and an optional friendly name which can be specified by using CSV syntax of hashValue,friendlyIdentifier';

  modes = COLLECTION_MODES;
  mode = this.modes.add; // can be add, editRolling, editFixed, or adhoc
  private defaultCollectionQuery = '';
  private defaultCollectionType: CollectionType = 'rolling';
  contentTypes = ContentTypes;
  collection: Collection;
  testError = '';
  timeBegin: Date = new Date();
  timeEnd: Date = new Date();

  name = '';
  nameValid = false;
  nameInvalidMessage = '';
  collectionType: CollectionType = this.defaultCollectionType;
  lastHours = 1;
  selectedUseCase?: UseCase;
  useCaseBinding: 'bound' | 'unbound' = 'bound';
  selectedContentTypes: string[] = [];
  contentLimit: number;
  minX: number;
  minY: number;
  distillationEnabled = false;
  distillationTerms = '';
  regexDistillationEnabled = false;
  regexDistillationTerms = '';
  regexDistillationTooltipText = `Uses perl-style regular expressions.

  Only match functionality is supported.

  Perl-style modifiers such as 'i' for case-insensitivity are NOT supported.

  Search only words, and do not use beginning or end of line metacharacters (e.g. '^' or '$').

  Note that multi-word matches may or may not work, depending on how the document was laid out internally and how the text is generated by 'pdftotext'.`;
  sha1Enabled = false;
  sha1Hashes = '';
  sha256Enabled = false;
  sha256Hashes = '';
  md5Enabled = false;
  md5Hashes = '';
  okButtonText: 'Execute' | 'Save' | 'Update';

  queryInputText?: string;
  queryList = defaultNwQueries;
  private queryListObj: Record<string, Query> = {};
  queryListOptions: SelectItem<string>[] = [];

  selectedQuery = this.queryList[2].text;
  private preferences: Preferences;
  private timeframes: string[] = ['Last 5 Minutes', 'Last 10 Minutes', 'Last 15 Minutes', 'Last 30 Minutes', 'Last Hour', 'Last 3 Hours', 'Last 6 Hours', 'Last 12 Hours', 'Last 24 Hours', 'Last 48 Hours', 'Last 5 Days (120 Hours)', 'Today', 'Yesterday', 'This Week', 'Last Week', 'Custom'];
  timeframeOptions: SelectItem<string>[] = [];
  selectedTimeframe = 'Last Hour';
  displayCustomTimeframeSelector = false;
  private firstRun = true;
  hashInfoText = `Matches on executables.<br><br>
  Case-insensitive.<br><br>
  May be in CSV format<br>
  (<b>hash,friendlyName</b>),<br>
  or a hash value only.<br><br>
  One item per-line.`;

  useCases: UseCase[];
  useCasesObj: Record<string, UseCase> = {};
  useCaseOptions: SelectItem<UseCase | undefined>[] = [];
  displayUseCaseDescription = false;
  useCaseDescription = '';

  imagesEnabled = false;
  pdfsEnabled = false;
  officeEnabled = false;
  dodgyArchivesEnabled = false;
  hashesEnabled = false;

  private editingCollectionId: string;
  private editingCreator: CollectionMeta;
  thumbClass = '';
  testInProgress = false;
  private reOpenTabsModal = false;

  private feeds: Feeds = {};
  hashingModes = HASHING_MODES;
  hashingMode = this.hashingModes.feed;
  feedOptions: SelectItem<Feed>[] = [];
  selectedFeed: Feed;
  private hashFeedId?: string;

  private collectionNames = new Set<string>();
  private origName?: string;

  private adhocParams: Params;

  onlyContentFromArchives = false;
  confirmationKey = 'NwCollectionModal';
  popupConfirmationKey = 'NwCollectionModalPopup';


  // API Servers
  addingService = true; // if true, we're adding a service.  If false, we're editing a service
  selectedNwServer?: NwServer;
  nwServers: NwServers = {};
  nwServersOptions: SelectItem<NwServer>[];
  private setThisApiServerIdOnNextPick?: string;


  // Subscriptions
  private subscriptions = new Subscription();



  get distillationOptionsEnabled() {
    return (this.selectedUseCase
    && this.useCaseBinding === 'unbound')
    || (!this.selectedUseCase && (this.pdfsEnabled
      || this.officeEnabled));
  }

  get customControlsEnabled() {
    return this.selectedUseCase === undefined || (this.selectedUseCase !== undefined && this.useCaseBinding === 'unbound');
  }

  get submitButtonEnabled(): boolean {
    // log.debug('NwCollectionModalComponent: submitEnabled()');
    if (Object.keys(this.nwServers).length === 0) {
      return false;
    }
    else if (!this.selectedNwServer) {
      return false;
    }
    if (!(this.selectedNwServer.id in this.nwServers)) {
      return false;
    }
    if (this.addCollectionForm.form.valid && this.selectedNwServer) {
      return true;
    }
    return false;
  }




  ngOnInit(): void {
    log.debug('NwCollectionModalComponent: ngOnInit()');

    for (const ql of this.queryList) {
      this.queryListObj[ql.text] = ql;
      this.queryListOptions.push({
        label: ql.text,
        value: ql.text
      });
    }

    this.subscriptions.add(
      this.toolService.reOpenTabsModal.subscribe(
        (TorF) => this.reOpenTabsModal = TorF
      )
    );

    // Preferences changed subscription
    this.subscriptions.add(
      this.dataService.preferencesChanged.subscribe(
        (prefs) => this.onPreferencesChanged(prefs)
      )
    );

    this.subscriptions.add(
      this.dataService.useCasesChanged.subscribe(
        (useCases) => this.onUseCasesChanged(useCases)
      )
    );

    // Add collection next subscription
    this.subscriptions.add(
      this.toolService.addNwCollectionNext.subscribe(
        () => this.onAddCollectionNext()
      )
    );

    // Edit collection next subscription
    this.subscriptions.add(
      this.toolService.editNwCollectionNext.subscribe(
        (collection) => this.onEditCollectionNext(collection)
      )
    );

    this.subscriptions.add(
      this.dataService.feedsChanged.subscribe(
        (feeds) => this.onFeedsChanged(feeds)
      )
    );

    this.subscriptions.add(
      this.dataService.collectionsChanged.subscribe(
        (collections) => this.onCollectionsChanged(collections)
      )
    );

    this.subscriptions.add(
      this.toolService.addNwAdhocCollectionNext.subscribe(
        (params) => this.onAdhocCollectionNext(params)
      )
    );

    this.subscriptions.add(
      this.dataService.nwServersChanged.subscribe(
        (apiServers) => this.onApiServersChanged(apiServers)
      )
    );

    this.subscriptions.add(
      this.toolService.displayNwCollectionModal.subscribe(
        (displayNwCollectionModal) => {
          if (!displayNwCollectionModal) {
            this.onClose();
          }
        }
      )
    );

    this.timeframes.forEach(timeframe => {
      const item: SelectItem = { label: timeframe, value: timeframe};
      this.timeframeOptions.push(item);
    });
  }



  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }



  ////////////// Subscription Handlers //////////////



  onPreferencesChanged(prefs?: Preferences): void {
    log.debug('NwCollectionModalComponent: onPreferencesChanged(): prefs observable: ', prefs);
    if (!prefs) {
      return;
    }

    if (Object.keys(prefs).length === 0) {
      return; // this handles a race condition where we subscribe before the getPreferences call has actually run
    }
    this.preferences = prefs;

    // We can update this every time
    if ( 'presetQuery' in prefs.nw ) {
      this.defaultCollectionQuery = prefs.nw.presetQuery;
      // this.queryInputText = prefs.presetQuery;
    }

    if (this.firstRun) { // we only want to update these the first time we open.  After that, leave them alone, as we don't want the user to have to change them every time he opens the window.  In other words, leave the last-used settings for the next time the user opens the modal

      if ( 'defaultQuerySelection' in prefs.nw ) {
        for (const query of this.queryList) {
          if (query.text === prefs.nw.defaultQuerySelection) {
            log.debug('NwCollectionModalComponent: onPreferencesChanged(): setting query selector to ', query);
            this.selectedQuery = query.text; // changes the query in the query select box dropdown
            this.queryInputText = query.queryString; // changes the query string in the query string input
            break;
          }
        }
      }
      this.minX = prefs.minX;
      this.minY = prefs.minY;
      this.contentLimit = prefs.defaultContentLimit;
      this.lastHours = prefs.defaultRollingHours;
      if ( 'presetQuery' in prefs.nw && prefs.nw.defaultQuerySelection === 'Default Query' ) {
        this.selectedQuery = 'Preset Query';
        this.queryInputText = prefs.nw.presetQuery; // changes the query string in the query string input
      }
    }

    this.firstRun = false;
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onCollectionsChanged(collections: Collections): void {
    if (Object.keys(collections).length === 0) {
      return;
    }
    this.collectionNames = new Set<string>(Object.keys(collections));
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onFeedsChanged(feeds: Feeds): void {
    if (Object.keys(feeds).length === 0) {
      return;
    }
    log.debug('NwCollectionModalComponent: onFeedsChanged(): feeds', feeds);
    const feedOptions: SelectItem[] = [];
    for (const i in feeds) {
      if (feeds.hasOwnProperty(i)) {
        const feed = feeds[i];
        const name = feed.name;
        feedOptions.push( { label: name, value: feed } );
      }
    }
    this.feeds = feeds;
    this.feedOptions = feedOptions;

    if (this.hashFeedId && this.hashFeedId in feeds) {
      this.selectedFeed = this.feeds[this.hashFeedId];
    }
    else {
      this.selectedFeed = this.feedOptions[0].value;
    }
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onUseCasesChanged(useCases: ClientUseCases): void {
    if (Object.keys(useCases).length === 0) {
      return;
    }
    log.debug('NwCollectionModalComponent: onUseCasesChanged(): o', useCases);
    this.useCases = useCases.useCases;
    this.useCasesObj = useCases.useCasesObj;
    this.useCaseOptions = [
      {
        label: 'Custom',
        value: undefined
      },
      ...this.useCases.map( (useCase) => ({
        label: useCase.friendlyName,
        value: useCase
      }) )
    ];
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }






  /////////// Form Events ///////////




  onDistillationChecked() {
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onNameChanged(name: string): void {
    // log.debug(`NwCollectionModalComponent: onNameChanged(): name: "${name}"`);

    if (name.length === 0) {
      this.nameValid = false;
      this.nameInvalidMessage = 'The name field is required';
    }
    else if (name.length !== 0 && !this.collectionNames.has(name) || (this.mode === this.modes.editRolling && name === this.origName))  {
      this.nameValid = true;
      this.nameInvalidMessage = '';
    }
    else {
      this.nameValid = false;
      this.nameInvalidMessage = 'A collection with this name already exists';
    }
  }



  onQuerySelected(detectChanges = true): void {
    // log.debug('NwCollectionModalComponent: onQuerySelected(): e', e);
    if (this.selectedQuery === 'Default Query') {
      this.queryInputText = this.defaultCollectionQuery;
    }
    else {
      this.queryInputText = this.queryListObj[this.selectedQuery].queryString;
    }
    if (detectChanges) {
      this.changeDetectionRef.markForCheck();
      this.changeDetectionRef.detectChanges();
    }
  }



  timeframeSelected(): void {
    if (this.selectedTimeframe === 'Custom') {
      // display custom timeframe selector
      this.displayCustomTimeframeSelector = true;
    }
    else {
      this.displayCustomTimeframeSelector = false;
    }
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  timeframeClicked() {
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onAddNwServiceClicked(): void {
    log.debug('NwCollectionModalComponent: onAddNwServiceClicked()');
    this.addingService = true; // set mode to adding
    this.displayServiceModal = true;
    this.changeDetectionRef.detectChanges();
  }



  onClose(): void {
    log.debug('NwCollectionModalComponent: onClose()');
    this.displayServiceModal = false;
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();

    if (this.mode === this.modes.editRolling || this.mode === this.modes.editFixed) {
      this.name = '';
      this.changeDetectionRef.markForCheck();
      this.changeDetectionRef.detectChanges();
    }
    if (this.reOpenTabsModal) {
      this.toolService.displayTabContainerModal.next(true);
    }
  }



  close(): void {
    log.debug('NwCollectionModalComponent: close()');
    this.toolService.displayNwCollectionModal.next(false);
    if (this.okButtonText === 'Save') {
      this.toolService.displayTabContainerModal.next(true);
    }
  }



  async onCollectionSubmit(f: NgForm): Promise<void> {
    // log.debug('NwCollectionModalComponent: onCollectionSubmit()');
    const time = Math.round( (new Date().getTime()) / 1000);
    if (!this.selectedNwServer) {
      throw new Error('selectedNwServer is not defined');
    }

    const newCollection: Partial<Collection> = {
      id: UUIDv4(), // overridden later if editing collection
      name: this.name,
      type: this.collectionType,
      state: 'initial',
      nwserver: this.selectedNwServer.id,
      nwserverName: this.selectedNwServer.friendlyName,
      contentLimit: this.contentLimit,
      deviceNumber: this.selectedNwServer.deviceNumber,
      bound: false, // may get overridden later
      usecase: 'custom', // may get overridden later
      onlyContentFromArchives: this.onlyContentFromArchives,
      executeTime: time,
      serviceType: 'nw'
    };

    if (this.selectedUseCase && this.useCaseBinding === 'bound') {
      // An OOTB use case is selected and is bound
      newCollection.usecase = this.selectedUseCase.name;
      newCollection.bound = true;

      for (const thisUseCase of this.useCases) {
        // set minX and minY if the use case uses images
        let outerBreak = false;

        if (thisUseCase.name === newCollection.usecase) {
          const contentTypes = thisUseCase.contentTypes;
          for (const contentType of contentTypes) {
            if ( contentType === 'images') {
              newCollection.minX = this.minX;
              newCollection.minY = this.minY;
              outerBreak = true;
              break;
            }
          }
          if (outerBreak) {
            break;
          }
        }
      }
    }
    else {
      // We either have a custom use case or an unbound use case
      newCollection.query = this.queryInputText;

      if (this.mode === this.modes.adhoc) {
        log.debug('NwCollectionModalComponent: onCollectionSubmit(): queryInputText:', this.queryInputText);
        let query = this.queryInputText;

        if ('host' in this.adhocParams) {
          query = `${query} && alias.host contains '${this.adhocParams.host}'`;
        }
        if ('ip' in this.adhocParams && this.adhocParams.side === 'src') {
          query = `${query} && ip.src = ${this.adhocParams.ip}`;
        }
        if ('ip' in this.adhocParams && this.adhocParams.side === 'dst') {
          query = `${query} && ip.dst = ${this.adhocParams.ip}`;
        }
        if ('adUser' in this.adhocParams && this.adhocParams.side === 'src') {
          query = `${query} && ad.username.src = '${this.adhocParams.adUser}'`;
        }
        if ('adUser' in this.adhocParams && this.adhocParams.side === 'dst') {
          query = `${query} && ad.username.dst = '${this.adhocParams.adUser}'`;
        }
        log.debug('NwCollectionModalComponent: onCollectionSubmit(): query:', query);
        newCollection.query = query;
      }

      newCollection.distillationEnabled = this.distillationEnabled;
      newCollection.regexDistillationEnabled = this.regexDistillationEnabled;
      newCollection.contentTypes = this.selectedContentTypes;

      for(const contentType of newCollection.contentTypes ?? []) {
        if (contentType === 'images') {
          newCollection.minX = this.minX;
          newCollection.minY = this.minY;
        }
      }

      if (!newCollection.bound && this.hashesEnabled && this.hashingMode === this.hashingModes.manual) {
        newCollection.useHashFeed = false;
        newCollection.md5Enabled = this.md5Enabled;
        newCollection.sha1Enabled = this.sha1Enabled;
        newCollection.sha256Enabled = this.sha256Enabled;
      }
      if (!newCollection.bound && this.hashesEnabled && this.hashingMode === this.hashingModes.feed && this.selectedFeed) {
        newCollection.useHashFeed = true;
        newCollection.hashFeed = this.selectedFeed.id;
      }
    }

    if ( this.collectionType === 'rolling' ) {
      newCollection.lastHours = this.lastHours;
    }
    else if ( this.collectionType === 'fixed' ) {
      const t = this.selectedTimeframe === 'Custom'
        ? utils.convertCustomTimeSelection(this.timeBegin, this.timeEnd)
        : utils.convertTimeSelection(this.selectedTimeframe);
      newCollection.timeBegin = t.timeBegin;
      newCollection.timeEnd = t.timeEnd;
    }


    if (!newCollection.bound && this.distillationEnabled ) {
      const endterms = utils.grokLines(this.distillationTerms);
      newCollection.distillationEnabled = false;
      if ( endterms.length !== 0 ) {
        newCollection.distillationEnabled = true;
        newCollection.distillationTerms = endterms;
      }
    }

    if (!newCollection.bound && this.regexDistillationEnabled) {
      const endterms = utils.grokLines(this.regexDistillationTerms);
      newCollection.regexDistillationEnabled = false;
      if ( endterms.length !== 0 ) {
        newCollection.regexDistillationEnabled = true;
        newCollection.regexDistillationTerms = endterms;
      }
    }

    if (!newCollection.bound && this.hashesEnabled && this.sha1Enabled) {
      const endterms = utils.grokHashingLines(this.sha1Hashes);
      newCollection.sha1Enabled = false;
      if ( endterms.length !== 0 ) {
        newCollection.sha1Enabled = true;
        newCollection.sha1Hashes = endterms;
      }
    }

    if (!newCollection.bound && this.hashesEnabled && this.sha256Enabled) {
      const endterms = utils.grokHashingLines(this.sha256Hashes);
      newCollection.sha256Enabled = false;
      if ( endterms.length !== 0 ) {
        newCollection.sha256Enabled = true;
        newCollection.sha256Hashes = endterms;
      }
    }

    if (!newCollection.bound && this.hashesEnabled && this.md5Enabled) {
      const endterms = utils.grokHashingLines(this.md5Hashes);
      newCollection.md5Enabled = false;
      if ( endterms.length !== 0 ) {
        newCollection.md5Enabled = true;
        newCollection.md5Hashes = endterms;
      }
    }

    try {
      if ([this.modes.add, this.modes.editFixed, this.modes.adhoc].includes(this.mode)) {
        log.debug('NwCollectionModalComponent: onCollectionSubmit(): new newCollection:', newCollection);
        await this.dataService.addCollection(newCollection);
        this.toolService.executeAddCollection.next( newCollection as Collection );
      }
      if (this.mode === this.modes.editRolling) {
        newCollection.id = this.editingCollectionId;
        newCollection.creator = this.editingCreator;
        log.debug('NwCollectionModalComponent: onCollectionSubmit(): edited newCollection:', newCollection);
        await this.dataService.editCollection(newCollection);
        this.toolService.executeEditCollection.next( newCollection as Collection );
      }
      this.reOpenTabsModal = false;
      this.close();
      this.name = '';

    }
    catch (error: any) {
      throw error;
    }
  }



  onSelectedTypesChanged(): void {
    log.debug('NwCollectionModalComponent: onSelectedTypesChanged()');
    const contentTypes = this.selectedContentTypes;
    let imagesEnabled = false;
    let pdfsEnabled = false;
    let officeEnabled = false;
    let dodgyArchivesEnabled = false;
    let hashesEnabled = false;
    for (const contentType of contentTypes) {
      if (contentType === 'images') {
        imagesEnabled = true;
      }
      if (contentType === 'pdfs') {
        pdfsEnabled = true;
      }
      if (contentType === 'officedocs') {
        officeEnabled = true;
      }
      if (contentType === 'dodgyarchives') {
        dodgyArchivesEnabled = true;
      }
      if (contentType === 'hashes') {
        hashesEnabled = true;
      }
    }
    if ( !(officeEnabled || pdfsEnabled) ) {
      this.distillationEnabled = false;
      this.regexDistillationEnabled = false;
    }
    if (!hashesEnabled) {
      this.sha1Enabled = false;
      this.sha256Enabled = false;
      this.md5Enabled = false;
    }
    this.imagesEnabled = imagesEnabled;
    this.pdfsEnabled = pdfsEnabled;
    this.officeEnabled = officeEnabled;
    this.dodgyArchivesEnabled = dodgyArchivesEnabled;
    this.hashesEnabled = hashesEnabled;
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onClearTypesSelected(): void {
    this.selectedContentTypes = [];
    this.onSelectedTypesChanged(); // runs change detection
  }



  onAllTypesSelected() {
    this.selectedContentTypes = this.contentTypes.map( (contentType) => contentType.value);
    this.onSelectedTypesChanged(); // runs change detection
  }



  onUseCaseChanged(): void {
    log.debug('NwCollectionModalComponent: onUseCaseChanged()');

    let displayUseCaseDescription = false;
    let thisUseCase: UseCase | undefined;

    for (const useCase of this.useCases) {
      if (useCase.name === this.selectedUseCase?.name) {
        thisUseCase = useCase;
        displayUseCaseDescription = true;
        this.useCaseDescription = useCase.description;
        break;
      }
    }
    this.displayUseCaseDescription = displayUseCaseDescription;

    if (this.useCaseBinding === 'unbound') {
      this.selectedQuery = 'Custom Query';
    }

    if (!this.selectedUseCase) {
      this.onSelectedTypesChanged(); // runs change detection
      return;
    }

    // an OOTB use case has been selected
    if (thisUseCase) {
      log.debug('NwCollectionModalComponent: onUseCaseChanged: thisUseCase:', thisUseCase);
      this.queryInputText = thisUseCase.nwquery;
      this.selectedContentTypes = thisUseCase.contentTypes;
      this.onlyContentFromArchives = thisUseCase.onlyContentFromArchives || false;
      this.distillationEnabled = false;
      if (thisUseCase.distillationTerms) {
        this.distillationEnabled = true;
        this.distillationTerms = thisUseCase.distillationTerms.join('\n');
      }
      this.regexDistillationEnabled = false;
      if (thisUseCase.regexTerms) {
        this.regexDistillationEnabled = true;
        this.regexDistillationTerms = thisUseCase.regexTerms.join('\n');
      }
    }
    this.onSelectedTypesChanged(); // runs change detection
  }



  onUseCaseBoundChanged(): void {
    log.debug('NwCollectionModalComponent: onUseCaseBoundChanged()');

    if (this.useCaseBinding === 'bound') {
      this.onUseCaseChanged(); // this is needed to update the content types, distillation terms, etc
    }
    else {
      // unbound
      this.selectedQuery = 'Custom Query';
    }
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  private convertArrayToString(a: string[]): string {
    let text = '';
    for (let i = 0; i < a.length; i++) {
      text += a[i];
      if (i < a.length - 1) { // omit the newline on the last line
       text += '\n';
      }
    }
    return text;
  }



  private onAddCollectionNext(): void {
    log.debug('NwCollectionModalComponent: onAddCollectionNext()');
    this.hashFeedId = undefined;
    this.mode = this.modes.add;
    this.okButtonText = 'Execute';
    this.name = '';
    this.nameBoxRef.first.nativeElement.focus();
    this.selectedUseCase = undefined; // this sets it to 'custom'
    this.displayUseCaseDescription = false;
    if (Object.keys(this.nwServers).length !== 0) {
      const firstApiServerId = Object.keys(this.nwServers)[0];
      this.selectedNwServer = this.nwServers[firstApiServerId];
      log.debug('NwCollectionModalComponent: onAddCollectionNext(): selectedApiServer.id', this.selectedNwServer.id);
    }
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  private onAdhocCollectionNext(params: Params): void {
    log.debug('NwCollectionModalComponent: onAdhocCollectionNext(): params:', params);

    if (Object.keys(params).length === 0) {
      return;
    }

    this.okButtonText = 'Execute';

    this.adhocParams = params;

    this.hashFeedId = undefined;
    this.mode = this.modes.adhoc;

    // Collection type
    this.collectionType = 'fixed';

    // Collection name
    const now = dayjs().format('YYYY/MM/DD HH:mm:ssZ');
    if ('host' in params) {
      this.name = `Adhoc investigation for host '${params.host}' at ${now}`;
    }
    else if ('ip' in params) {
      this.name = `Adhoc investigation for ${params.side} IP ${params.ip} at ${now}`;
    }
    else if ('adUser' in params) {
      this.name = `Adhoc investigation for ${params.side} AD User ${params.adUser} at ${now}`;
    }

    this.onNameChanged(this.name);
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
    this.nameBoxRef.first.nativeElement.focus();

    // Use case
    this.selectedUseCase = undefined; // this sets it to 'custom'
    this.displayUseCaseDescription = false;

    // Query
    this.selectedQuery = this.queryList[0].text; // select all types
    this.onQuerySelected(); // runs change detection


    // Content types
    this.selectedContentTypes = [ 'pdfs', 'officedocs', 'images', 'dodgyarchives' ];
    this.onSelectedTypesChanged(); // runs change detection

    // Timeframe
    this.selectedTimeframe = 'Last 24 Hours';

    // API Server
    if (Object.keys(this.nwServers).length !== 0) {
      const firstApiServerId = Object.keys(this.nwServers)[0];
      this.selectedNwServer = this.nwServers[firstApiServerId];
      log.debug('NwCollectionModalComponent: onAdhocCollectionNext(): selectedApiServer.id', this.selectedNwServer.id);
    }
    this.toolService.displayNwCollectionModal.next(true);
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  private onEditCollectionNext(collection: Collection): void {
    // Called when we receive an edit signal from toolbar
    log.debug('NwCollectionModalComponent: onEditCollectionNext(): collection:', collection);
    this.collection = collection;

    if (collection.type === 'fixed') {
      this.okButtonText = 'Execute';
      this.useCaseBinding = 'unbound';
    }
    else if (!this.toolService.selectedCollection || collection.id !== this.toolService.selectedCollection.id ) {
      // update rolling collection that isn't selected
      this.okButtonText = 'Save';
    }
    else {
      // update rolling collection that is selected
      this.okButtonText = 'Update';
    }

    if (collection.type === 'rolling' || collection.type === 'monitoring' ) {
      this.mode = this.modes.editRolling;
      this.editingCollectionId = collection.id;
      if ('creator' in collection) {
        this.editingCreator = collection.creator;
      }
      if (collection.type === 'rolling' && collection.lastHours !== undefined) {
        this.lastHours = collection.lastHours;
      }
    }
    else {
      this.mode = this.modes.editFixed;
    }

    this.name = collection.name;
    this.origName = collection.name;
    this.onNameChanged(collection.name); // runs change detection
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
    this.collectionType = collection.type;
    this.contentLimit = collection.contentLimit;
    this.onlyContentFromArchives = collection.onlyContentFromArchives || false;
    if ('minX' in collection && 'minY' in collection) {
      this.minX = collection.minX;
      this.minY = collection.minY;
    }
    else {
      this.minX = this.preferences.minX;
      this.minY = this.preferences.minY;
    }
    this.selectedUseCase = this.useCasesObj[collection.usecase];

    if (collection.bound) {
      this.useCaseBinding = 'bound';
      this.onUseCaseBoundChanged();
      this.onUseCaseChanged();
    }
    else {
      // unbound or custom collection
      this.useCaseBinding = 'unbound';
      this.selectedContentTypes = collection.contentTypes;
      this.displayUseCaseDescription = false;
      let foundQuery = false;
      // now try to match the collection query to our predefined queries
      for (const query of this.queryList) {
        if (query.queryString === collection.query) {
          this.selectedQuery = query.text;
          foundQuery = true;
        }
      }
      if (!foundQuery) {
        this.selectedQuery = 'Custom Query';
      }
      this.queryInputText = collection.query;
      this.onUseCaseBoundChanged();
      this.onUseCaseChanged();
    }

    if (collection.serviceType === 'nw' && collection.nwserver in this.nwServers) {
      log.debug(`NwCollectionModalComponent: onEditCollectionNext(): Collection's nwserver ${collection.nwserver} is defined`);
      const firstApiServerId = collection.nwserver;
      this.selectedNwServer = this.nwServers[firstApiServerId];
    }
    else if (collection.serviceType === 'nw') {
      log.debug(`NwCollectionModalComponent: onEditCollectionNext(): Collection's nwserver ${collection.nwserver} is not currently defined.  It must've been deleted.`);
      this.selectedNwServer = undefined;
    }

    if (collection.distillationEnabled) {
      this.distillationEnabled = true;
      this.distillationTerms = this.convertArrayToString(collection.distillationTerms);
    }
    else {
      this.distillationEnabled = false;
    }

    if (collection.regexDistillationEnabled) {
      this.regexDistillationEnabled = true;
      this.regexDistillationTerms = this.convertArrayToString(collection.regexDistillationTerms);
    }
    else {
      this.regexDistillationEnabled = false;
    }

    if (collection.useHashFeed) {
      this.hashingMode = this.hashingModes.feed;
      this.hashFeedId = collection.hashFeed;
      // now get the feed object and stick it in selectedFeed
    }
    else {
      this.hashingMode = this.hashingModes.manual;
      if (collection.sha1Enabled && collection.sha1Hashes) {
        this.sha1Enabled = true;
        this.sha1Hashes = utils.getHashesFromCollection(collection.sha1Hashes);
      }
      else {
        this.sha1Enabled = false;
      }

      if (collection.sha256Enabled && collection.sha256Hashes) {
        this.sha256Enabled = true;
        this.sha256Hashes = utils.getHashesFromCollection(collection.sha256Hashes);
      }
      else {
        this.sha256Enabled = false;
      }

      if (collection.md5Enabled && collection.md5Hashes) {
        this.md5Enabled = true;
        this.md5Hashes = utils.getHashesFromCollection(collection.md5Hashes);
      }
      else {
        this.md5Enabled = false;
      }
    }
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  /////////// API Servers ///////////



  private onApiServersChanged(apiServers: NwServers) {
    log.debug('NwCollectionModalComponent: onApiServersChanged(): apiServers:', apiServers);
    this.nwServers = apiServers;
    this.nwServersOptions = Object.values(apiServers).map( server => ({
      label: server.friendlyName,
      value: server
    }));

    this.pickAnApiServer();
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  private pickAnApiServer(): void {
    log.debug('NwCollectionModalComponent: pickAnApiServer()');
    const len = Object.keys(this.nwServers).length;
    if (!len) {
      // no API servers are defined
      this.selectedNwServer = undefined;
    }
    else if (len && !this.selectedNwServer) {
      this.selectedNwServer = this.nwServers[0];
    }
    else if (this.setThisApiServerIdOnNextPick) {
      // we predetermined which server we're going to choose.  Only used if onNewApiServer() has run
      this.selectedNwServer = this.nwServers[this.setThisApiServerIdOnNextPick];
      this.setThisApiServerIdOnNextPick = undefined;
    }
    else if (this.selectedNwServer && !Object.keys(this.nwServers).includes(this.selectedNwServer.id)) {
      // we got new api servers and our selected server isn't one of them (deletion).
      // let's make no assumptions and force the user to select one
      this.selectedNwServer = undefined;
    }
    // we got new api servers and our selected server is one of them - do nothing
  }



  onNewApiServer(newServerId: string) {
    log.debug('NwCollectionModalComponent: onNewApiServer(): newServer:', newServerId);
    // select the new server
    this.selectedNwServer = this.nwServers[newServerId];
    this.changeDetectionRef.detectChanges();
  }



  onDeleteApiServerClicked(event: Event, server: NwServer | SaServer): void {
    log.debug('NwCollectionModalComponent: onDeleteApiServerClicked()', {serverId: server.id});

    this.confirmationService.confirm({
      target: event.target as EventTarget,
      icon: 'pi pi-exclamation-triangle',
      message: `Are you sure you want to delete NetWitness server ${server.friendlyName}?`,
      accept: () => this.onDeleteApiServerConfirmed(server.id),
      acceptLabel: 'Yes',
      key: this.popupConfirmationKey
    });
  }



  async onDeleteApiServerConfirmed(serverId: string): Promise<void> {
    try {
      await this.dataService.deleteNwServer(serverId);
      this.selectedNwServer = undefined;
    }
    catch (error: any) {
      log.error('There was an error when deleting the collection:', error);
      throw error;
      // this.error = error.error;
    }
  }



  async onTestApiServerClicked(server: NwServer): Promise<void> {
    if (this.testInProgress) {
      return;
    }

    this.testError = 'Test in progress';
    this.thumbClass = '';
    this.testInProgress = true;
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();

    try {
      await this.dataService.testNwServer(server);
      this.testInProgress = false;
      const msg = 'Connection was successful';
      this.thumbClass = 'fa-thumbs-up';
      this.testError = msg;
    }
    catch (error: any) {
      this.testInProgress = false;
      const msg = 'Connection failed';
      this.thumbClass = 'fa-thumbs-down';
      this.testError = msg;
      log.info('Test connection failed with error:', error);
    }
    finally {
      this.changeDetectionRef.markForCheck();
      this.changeDetectionRef.detectChanges();
    }
  }



  onEditApiServerClicked(): void {
    log.debug('NwCollectionModalComponent: onEditApiServerClicked()');
    this.addingService = false; // set mode to editing
    this.displayServiceModal = true;
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onApiServerClicked() {
    log.debug('NwCollectionModalComponent: onApiServerClicked(): selectedApiServer:', this.selectedNwServer);
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onSetDefaultApiServerClicked() {
    if (!this.selectedNwServer) {
      return;
    }
    this.toolService.setPreference('defaultNwService', this.selectedNwServer.id);
  }



  onTabClicked() {
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onEditServiceModalClosed() {
    this.displayServiceModal = false;
    this.changeDetectionRef.markForCheck();
    this.changeDetectionRef.detectChanges();
  }



  onSelectedUseCaseChange(value: UseCase & SelectItem): void {
    // this is needed because of https://github.com/primefaces/primeng/issues/11420
    if (value.label) {
      this.selectedUseCase = undefined;
      return;
    }
    this.selectedUseCase = value;
  }
}
